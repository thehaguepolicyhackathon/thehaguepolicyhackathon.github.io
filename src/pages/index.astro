---
import H1 from "../components/h1.astro";
import H2 from "../components/h2.astro";
import Link from "../components/link.astro";
import Navigation from "../components/navigation";
import RootLayout from "../layouts/RootLayout.astro";
import AvailableForWork from "../components/available.astro";
import hague_vid from "../assets/hague-vid.mp4";
import hph_logo from "../assets/HPH_logo_white.png";
---

<RootLayout>
	<main>
		<div class="group relative w-full min-h-dvh flex items-center justify-center overflow-hidden">
			<!-- Background media container -->
			<div class="absolute w-full h-dvh -z-10 overflow-hidden">
				<!-- Option 1: Video background -->
				<video 
					class="w-full h-full object-cover"
					autoplay 
					muted 
					loop 
					playsinline
				>
					<source src={hague_vid} type="video/mp4" />
				</video>
				
				<!-- Option 2: Image background (comment out video above and uncomment this) -->
				<!-- <img 
					src="/your-image.jpg" 
					alt="Background"
					class="w-full h-full object-cover"
				/> -->

				<div class="absolute inset-0 bg-black/60"></div>
			</div>

			<!-- ASCII hover effect overlay -->
			<canvas 
				id="asciiCanvas" 
				class="absolute inset-0 w-full h-dvh pointer-events-none z-0"
			/>

			<div class="p-4 sm:p-8 absolute w-full h-dvh flex flex-col justify-between z-10">
				<!-- <div>
					<H1 size="default"> The Hague <br /> Policy <br /> Hackathon </H1>
				</div> -->
				<div class="flex flex-col gap-2 items-start">
					<img 
						src={hph_logo.src}
						alt="HPH logo"
						class="w-auto max-w-[210px] sm:max-w-[330px] md:max-w-[390px] h-auto -ml-5"
					/>
					
					<H2 size="default"> 22-24 May 2026</H2>
				</div>

				<div>
					<AvailableForWork className="py-4" />
					<div class="mb-2 sm:mb-4 flex items-center justify-between overflow-scroll no-scrollbar">
						<div class="flex items-center gap-4">
							<Link href="https://luma.com/zdvikk0n">Register your interest!</Link>
							<Link href="/about" variant="secondary">About</Link>
							<Link href="/faq" variant="secondary">FAQ</Link>
							<Link href="/team" variant="secondary">Team</Link>
							<Link href="/contact" variant="secondary">Contact</Link>
							<Link href="https://www.dpi.network/" variant="secondary">DPIN</Link>
							<Link href="https://www.thehagueea.org/" variant="secondary">THEA</Link>
						</div>
					</div>
				</div>
			</div>
		</div>
	</main>
</RootLayout>
<script is:inline>
	// ========================================
	// CUSTOMIZABLE TEXT BODY - PASTE YOUR TEXT HERE!
	// ========================================
	const TEXT_BODY = `Grondwet voor het Koninkrijk der Nederlanden van 24 augustus 1815

Algemene bepaling

De Grondwet waarborgt de grondrechten en de democratische rechtsstaat.

Hoofdstuk 1. Grondrechten

Artikel 1

Allen die zich in Nederland bevinden, worden in gelijke gevallen gelijk behandeld. Discriminatie wegens godsdienst, levensovertuiging, politieke gezindheid, ras, geslacht,Â handicap, seksuele gerichtheid of op welke grond dan ook, is niet toegestaan.

Artikel 2

1.	De wet regelt wie Nederlander is.

2.	De wet regelt de toelating en de uitzetting van vreemdelingen.

3.	Uitlevering kan slechts geschieden krachtens verdrag. Verdere voorschriften omtrent uitlevering worden bij de wet gegeven.

4.	Ieder heeft het recht het land te verlaten, behoudens in de gevallen, bij de wet bepaald.

Artikel 3

Alle Nederlanders zijn op gelijke voet in openbare dienst benoembaar.

Artikel 4

Iedere Nederlander heeft gelijkelijk recht de leden van algemeen vertegenwoordigende organen te verkiezen alsmede tot lid van deze organen te worden verkozen, behoudens bij de wet gestelde beperkingen en uitzonderingen.

Artikel 5

Ieder heeft het recht verzoeken schriftelijk bij het bevoegd gezag in te dienen.

Artikel 6

1.	Ieder heeft het recht zijn godsdienst of levensovertuiging, individueel of in gemeenschap met anderen, vrij te belijden, behoudens ieders verantwoordelijkheid volgens de wet.

2.	De wet kan ter zake van de uitoefening van dit recht buiten gebouwen en besloten plaatsen regels stellen ter bescherming van de gezondheid, in het belang van het verkeer en ter bestrijding of voorkoming van wanordelijkheden.

Artikel 7

1.	Niemand heeft voorafgaand verlof nodig om door de drukpers gedachten of gevoelens te openbaren, behoudens ieders verantwoordelijkheid volgens de wet.

2.	De wet stelt regels omtrent radio en televisie. Er is geen voorafgaand toezicht op de inhoud van een radio- of televisieuitzending.

3.	Voor het openbaren van gedachten of gevoelens door andere dan in de voorgaande leden genoemde middelen heeft niemand voorafgaand verlof nodig wegens de inhoud daarvan, behoudens ieders verantwoordelijkheid volgens de wet. De wet kan het geven van vertoningen toegankelijk voor personen jonger dan zestien jaar regelen ter bescherming van de goede zeden.

4.	De voorgaande leden zijn niet van toepassing op het maken van handelsreclame.

Artikel 8

Het recht tot vereniging wordt erkend. Bij de wet kan dit recht worden beperkt in het belang van de openbare orde.

Artikel 9

1.	Het recht tot vergadering en betoging wordt erkend, behoudens ieders verantwoordelijkheid volgens de wet.

2.	De wet kan regels stellen ter bescherming van de gezondheid, in het belang van het verkeer en ter bestrijding of voorkoming van wanordelijkheden.

Artikel 10

1.	Ieder heeft, behoudens bij of krachtens de wet te stellen beperkingen, recht op eerbiediging van zijn persoonlijke levenssfeer.

2.	De wet stelt regels ter bescherming van de persoonlijke levenssfeer in verband met het vastleggen en verstrekken van persoonsgegevens.

3.	De wet stelt regels inzake de aanspraken van personen op kennisneming van over hen vastgelegde gegevens en van het gebruik dat daarvan wordt gemaakt, alsmede op verbetering van zodanige gegevens.
`;
	// ========================================
	
	// Use is:inline to ensure script runs on every page load
	function initAsciiEffect() {
		const canvas = document.getElementById('asciiCanvas');
		if (!canvas) return;
		
		const ctx = canvas.getContext('2d');
		
		// Set canvas size
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		
		const fontSize = 14; // Smaller font
		const cellSize = 18; // Smaller cells
		const effectRadius = 80;
		const fadeSpeed = 0.03;
		
		let mouseX = -1000;
		let mouseY = -1000;
		let lastMoveTime = 0;
		let targetOpacity = 0;
		let currentOpacity = 0;
		let animationId = null;
		
		// Calculate how many characters fit per row
		const charsPerRow = Math.ceil(canvas.width / cellSize);
		
		// Function to get character for a specific grid position (reading left to right, top to bottom)
		function getCharForPosition(gridX, gridY) {
			const index = gridY * charsPerRow + gridX;
			return TEXT_BODY[index % TEXT_BODY.length] || ' ';
		}
		
		// Store character cells with their properties
		const activeCells = new Map();
		
		// Track mouse position
		function handleMouseMove(e) {
			mouseX = e.clientX;
			mouseY = e.clientY;
			lastMoveTime = Date.now();
			targetOpacity = 1;
			
			// Update active cells based on new mouse position
			updateActiveCells();
		}
		
		document.addEventListener('mousemove', handleMouseMove);
		
		function updateActiveCells() {
			// Calculate grid bounds around mouse
			const cols = Math.ceil(effectRadius * 2 / cellSize);
			const rows = Math.ceil(effectRadius * 2 / cellSize);
			
			const centerGridX = Math.floor(mouseX / cellSize);
			const centerGridY = Math.floor(mouseY / cellSize);
			
			const newCells = new Set();
			
			for (let i = -Math.floor(cols / 2); i < Math.ceil(cols / 2); i++) {
				for (let j = -Math.floor(rows / 2); j < Math.ceil(rows / 2); j++) {
					const gridX = centerGridX + i;
					const gridY = centerGridY + j;
					const key = `${gridX},${gridY}`;
					
					// Calculate actual position (snapped to grid)
					const x = gridX * cellSize + cellSize / 2;
					const y = gridY * cellSize + cellSize / 2;
					
					// Calculate distance from mouse
					const dx = x - mouseX;
					const dy = y - mouseY;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					// Only add cells within radius
					if (distance < effectRadius) {
						newCells.add(key);
						
						if (!activeCells.has(key)) {
							// Create new cell with character from text body in reading order
							activeCells.set(key, {
								char: getCharForPosition(gridX, gridY),
								gridX,
								gridY,
								x,
								y,
								opacity: 0,
								distanceFromCenter: distance
							});
						} else {
							// Update distance for existing cell
							const cell = activeCells.get(key);
							cell.distanceFromCenter = distance;
						}
					}
				}
			}
			
			// Mark cells for removal that are no longer in range
			activeCells.forEach((cell, key) => {
				if (!newCells.has(key)) {
					cell.opacity = Math.max(0, cell.opacity - fadeSpeed * 2);
				}
			});
		}
		
		// Animation loop
		function animate() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			const now = Date.now();
			const timeSinceMove = now - lastMoveTime;
			
			// Fade out if mouse hasn't moved in a while
			if (timeSinceMove > 100) {
				targetOpacity = Math.max(0, targetOpacity - 0.01);
			}
			
			// Smoothly interpolate current opacity
			currentOpacity += (targetOpacity - currentOpacity) * 0.1;
			
			// Remove fully faded cells
			const keysToDelete = [];
			activeCells.forEach((cell, key) => {
				if (cell.opacity <= 0 && targetOpacity === 0) {
					keysToDelete.push(key);
				}
			});
			keysToDelete.forEach(key => activeCells.delete(key));
			
			// Draw all active cells
			activeCells.forEach((cell) => {
				// Fade in/out based on target opacity
				if (currentOpacity > cell.opacity) {
					cell.opacity = Math.min(currentOpacity, cell.opacity + fadeSpeed);
				} else {
					cell.opacity = Math.max(0, cell.opacity - fadeSpeed);
				}
				
				if (cell.opacity > 0.01) {
					// Calculate vignette effect (fade at edges)
					const vignetteOpacity = 1 - (cell.distanceFromCenter / effectRadius);
					const finalOpacity = cell.opacity * vignetteOpacity;
					
					// Draw character with glow
					ctx.shadowBlur = 6;
					ctx.shadowColor = `rgba(255, 255, 255, ${finalOpacity * 0.4})`;
					ctx.fillStyle = `rgba(255, 255, 255, ${finalOpacity * 0.9})`;
					ctx.font = `bold ${fontSize}px monospace`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText(cell.char, cell.x, cell.y);
				}
			});
			
			// Reset shadow
			ctx.shadowBlur = 0;
			
			animationId = requestAnimationFrame(animate);
		}
		
		animate();
		
		// Handle window resize
		function handleResize() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}
		
		window.addEventListener('resize', handleResize);
		
		// Cleanup function
		return function cleanup() {
			if (animationId) {
				cancelAnimationFrame(animationId);
			}
			document.removeEventListener('mousemove', handleMouseMove);
			window.removeEventListener('resize', handleResize);
		};
	}
	
	// Initialize on page load
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initAsciiEffect);
	} else {
		initAsciiEffect();
	}
	
	// Re-initialize after Astro view transitions (if using them)
	document.addEventListener('astro:page-load', initAsciiEffect);
</script>